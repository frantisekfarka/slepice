%%
%% needs
%%    fodtt-syntax.ott
%%    fodtt-flas_{n,both}.ott
%%

embed
{{ coq

Definition fstSig (e : (con*eTy)+(tcon*eK) ) := match e with
    | inl (c, ty) => inl c
    | inr (alpha, k) => inr alpha
  end.

Definition boundCon c T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inl(c,T0)) S2)) /\
    ~In (inl(c)) (List.map (fstSig) S1).

Definition boundTCon alpha T0 S :=
  exists S1, exists S2,
    (S = List.app S1 (List.cons (inr(alpha,T0)) S2)) /\
    ~In (inr(alpha)) (List.map (fstSig) S1).

Definition boundVar x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst var eTy) G1).

Definition indomCon c S :=
  exists T0,
    boundCon c T0 S.

Definition indomTCon alpha S :=
  exists T0,
    boundCon alpha T0 S.

Definition indomVar x S :=
  exists T0,
    boundVar x T0 S.

}}
embed
{{ ocaml 
type ('a, 'b) sgn_el_type = Inl of 'a | Inr of 'b
}}


subrules

freevars
% due to recursive definition of Ty and K the fv_Ty and fk_K are also generated
%  Ty x :: tyfv
%  te x :: fv

substitutions
%  single K x :: tsubst
%  single Ty x :: tsubst
%  single te x :: subst

defns
Jwellformed :: '' ::=


  defn
  |-sig sgn :: ::wfsig::'sig_' {{ tex \vdash [[sgn]] \text{ sig} }} by

    ---------------  :: empty
    |-sig empty

    |-sig sgn
    sgn ; empty |- K : kindS
    alpha notin dom(sgn)
    -------------------------- :: tcon
    |-sig sgn,alpha:K

    |-sig sgn
    sgn ; empty |- A : typeK
    c notin dom(sgn) 
    -------------------------- :: con
    |-sig sgn,c:A

  defn
  sgn |-ctx ctx :: ::wfctx::'ctx_' {{tex [[sgn]] \vdash [[ctx]] \text{ ctx} }} by
   
    |-sig sgn
    --------------------  :: empty
    sgn |-ctx empty

    sgn |-ctx ctx
    sgn ; ctx |- A : typeK
    x notin dom(ctx) 
    -------------------------- :: var
    sgn |-ctx ctx,x:A

  defn
  sgn ; ctx |- K : kindS :: ::wfkind::'k_' {{tex [[sgn]] ; [[ctx]] \vdash [[K]] : [[kindS]]}} by

    sgn |-ctx ctx
    -----------------------------  :: type
    sgn ; ctx |- typeK : kindS

    sgn ; ctx,x:A |- K : kindS
    ----------------------------- :: pi_intro
    sgn ; ctx |- Pi x:A.K : kindS

  defn
  sgn ; ctx |- A : K  :: ::wftype::'ty_' {{tex [[sgn]] ; [[ctx]] \vdash [[A]] : [[K]]}} by

    sgn |-ctx ctx
    alpha : K in sgn
    ------------------  :: tcon
    sgn ; ctx |- alpha : K


    sgn ; ctx,x:A |- B : typeK
    ----------------------------------------- :: pi_intro
    sgn ; ctx |- Pi x : A . B : typeK 

    sgn ; ctx |- A : Pi x : B . K
    sgn ; ctx |- M : B
    ----------------------------------------- :: pi_elim
    sgn ; ctx |- A M : K [ M / x ] 

    sgn ; ctx |- A : L
    sgn ; ctx |- L is L' 
    ------------------------------ :: conv
    sgn ; ctx |- A : L' 

  defn
  sgn ; ctx |- M : A  :: ::wfterm::'te_' {{tex [[sgn]] ; [[ctx]] \vdash [[M]] : [[A]]}} by

    sgn |-ctx ctx
    c : A in sgn
    ----------------------  :: con
    sgn ; ctx |- c : A

    sgn |-ctx ctx
    x : A in ctx
    ----------------------  :: var
    sgn ; ctx |- x : A

    sgn ; ctx,x:A |- M : B 
    ---------------------------------- :: pi_intro
    sgn ; ctx |- \x:A.M : Pi x : A . B 

    sgn ; ctx |- M : Pi x : A . B 
    sgn ; ctx |- N : A
    ------------------------------ :: pi_elim
    sgn ; ctx |- M N : B [ N / x ]

    sgn ; ctx |- M : A
    sgn ; ctx |- A is A' : typeK
    ------------------------------ :: conv
    sgn ; ctx |- M : A' 

  defn 
  sgn ; ctx |- K is K' ::  :: substapkind :: 'eqK_' {{tex [[sgn]] ; [[ctx]]
  \vdash [[K]] \equiv [[K']] : \text{kind} }} by

    sgn ; ctx |- K : kindS
    --------------------------- :: refl
    sgn ; ctx |- K is K 

    sgn ; ctx |- K' is K 
    ---------------------------- :: sym
    sgn ; ctx |- K is K' 

    sgn ; ctx |- K_1 is K_2
    sgn ; ctx |- K_2 is K_3
    ------------------------------- :: trans
    sgn ; ctx |- K_1 is K_3

    sgn ; ctx |- A is A' : typeK
    sgn ; ctx |- L is L' 
    ------------------------------------ :: cong
    sgn ; ctx |- Pi x:A.L is Pi x:A'.L' 

  defn 
  sgn ; ctx |- A is A' : L ::  :: substaptype :: 'eqT_' 
  {{ tex [[sgn]] ; [[ctx]] \vdash [[A]] \equiv [[A']] : [[L]] }} by

    sgn ; ctx |- A : L
    --------------------------- :: refl
    sgn ; ctx |- A is A : L

    sgn ; ctx |- A' is A : L
    ---------------------------- :: sym
    sgn ; ctx |- A is A' : L

    sgn ; ctx |- A_1 is A_2 : L
    sgn ; ctx |- A_2 is A_3 : L
    ------------------------------- :: trans
    sgn ; ctx |- A_1 is A_3 : L

    sgn ; ctx |- A is A' : typeK 
    sgn ; ctx |- B is B' : typeK
    --------------------------------------- :: pi_intro_cong
    sgn ; ctx |- Pi x:A.B is Pi x:A'.B' : L

    sgn ; ctx |- A is A' : Pi x:B.L
    sgn ; ctx |- M is M' : B
    ------------------------------------ :: pi_elim_cong
    sgn ; ctx |- A M is A' M' : L[M/x]

  defn 
  sgn ; ctx |- M is M' : A ::  :: substapterm :: 'eqt_'
  {{ tex [[sgn]] ; [[ctx]] \vdash [[M]] \equiv [[M']] : [[A]] }} by

    sgn ; ctx |- M : A
    ----------------------- :: refl
    sgn ; ctx |- M is M : A

    sgn ; ctx |- M' is M : A
    ------------------------ :: sym
    sgn ; ctx |- M is M' : A

    sgn ; ctx |- M_1 is M_2 : A 
    sgn ; ctx |- M_2 is M_3 : A
    --------------------------- :: trans
    sgn ; ctx |- M_1 is M_3 : A

    sgn ; ctx |- M is M' : Pi x : A . B
    sgn ; ctx |- A is A' : typeK
    ------------------------------------------------- :: pi_intro_cong
    sgn ; ctx |- (\x:A.M) is (\x:A'.M') : Pi x : A . B

    sgn ; ctx |- M is M' : Pi x : A . B
    sgn ; ctx |- N is N' : A
    --------------------------------------- :: pi_elim_cong
    sgn ; ctx |- M N is M' N' : B [  N / x]

    sgn ; ctx |- A : typeK
    sgn ; ctx, x : A |- M x is M' x : B
    ------------------------------------------ :: ext
    sgn ; ctx |- M is N : Pi x : A . B


    sgn ; ctx , x : A |- M : B
    sgn ; ctx |- N : A
    -------------------------------------------------- :: red
    sgn ; ctx |- (\x:A.M) N is M [ N / x] : B [ N / x] 

    sgn ; ctx |- M is N : A
    sgn ; ctx |- A is B : typeK
    ------------------------------------------ :: conv
    sgn ; ctx |- M is N : B


